@file:Suppress("unused")

package com.yoavst.euler.problems

import com.yoavst.euler.*
import java.math.BigInteger

/**
 * We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once.
 * For example, 2143 is a 4-digit pandigital and is also prime.
 * What is the largest n-digit pandigital prime that exists?
 */
fun problem41() {
    val numbers = mutableSetOf<Int>()
    fun generateAll(data: CharArray, left: Int = 0) {
        if (left == data.size) {
            val num = String(data).toInt()
            if (num.isPrime()) {
                numbers += num
            }
        } else {
            for (i in left until data.size) {
                data.swap(i, left)
                generateAll(data, left + 1)
                data.swap(i, left)
            }
        }
    }

    for (i in 9 downTo 4) {
        generateAll((1..i).joinToString(separator = "").toCharArray())
        if (numbers.isNotEmpty()) {
            println(numbers.max())
            break
        }
    }
}

/**
 * The nth term of the sequence of triangle numbers is given by, tn = 0.5n(n+1); so the first ten triangle numbers are:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value.
 * For example, the word value for SKY is 19 + 11 + 25 = 55 = t10.
 * If the word value is a triangle number then we shall call the word a triangle word.
 * Using words.txt, a 16K text file containing nearly two-thousand common English words,
 * how many are triangle words?


 */
fun problem42() {
    val triangles = (1..30).map { n -> n * (n + 1) / 2 }.toIntArray()
    val count = resourceOf("p042_words.txt").readText().split(',').asSequence().map { it.substring(1, it.length - 1) }
            .map { it.sumBy { it - 'A' + 1 } }.count { triangles.binarySearch(it) >= 0 }

    println(count)
}

/**
 * The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order,
 * but it also has a rather interesting sub-string divisibility property.
 * Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:
 * d2d3d4=406 is divisible by 2
 * d3d4d5=063 is divisible by 3
 * d4d5d6=635 is divisible by 5
 * d5d6d7=357 is divisible by 7
 * d6d7d8=572 is divisible by 11
 * d7d8d9=728 is divisible by 13
 * d8d9d10=289 is divisible by 17
 * Find the sum of all 0 to 9 pandigital numbers with this property.
 */
fun problem43() {
    var sum = 0L
    val divisions = intArrayOf(2, 3, 5, 7, 11, 13, 17)
    fun CharArray.intOf(start: Int, end: Int) = String(this).substring(start, end).toInt()
    fun generateAll(data: CharArray = "0123456789".toCharArray(), left: Int = 0) {
        if (left == data.size) {
            var i = 1
            for (divider in divisions) {
                if (data.intOf(i, i + 3) % divider != 0)
                    return
                i++
            }
            sum += String(data).toLong()
        } else {
            for (i in left until data.size) {
                data.swap(i, left)
                generateAll(data, left + 1)
                data.swap(i, left)
            }
        }
    }

    generateAll()
    println(sum)
}

/**
 * Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 *     1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 *
 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 * Find the pair of pentagonal numbers, Pj and Pk,
 * for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
 */
fun problem44() {
    val numbers = (1L..10000).map { n -> n * (3 * n - 1) / 2 }.toLongArray()
    var minimalDiff = Long.MAX_VALUE

    for (a in numbers) {
        for (b in numbers) {
            val diff = (a - b).abs()
            if (numbers.binarySearch(a + b) >= 0 && numbers.binarySearch(diff) >= 0) {
                println("$a $b")
                if (diff < minimalDiff) {
                    minimalDiff = diff
                }
            }
        }
    }

    println(minimalDiff)
}

/**
 * Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
 *
 * Triangle	 	    Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 * Pentagonal	 	Pn=n(3n−1)/2	1, 5, 12, 22, 35, ...
 * Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
 *
 * It can be verified that T285 = P165 = H143 = 40755.
 *
 * Find the next triangle number that is also pentagonal and hexagonal.
 */
fun problem45() {
    fun Long.isHexagonal(): Boolean = ((Math.sqrt((8 * this + 1).toDouble()) + 1) / 4) % 1 == 0.0

    val num = (1L..Long.MAX_VALUE).asSequence().map { n -> n * (3 * n - 1) / 2 }.filter(Long::isHexagonal).elementAt(2)
    println(num)
}

/**
 * It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.
 * 9 = 7 + 2×1^2
 * 15 = 7 + 2×2^2
 * 21 = 3 + 2×3^2
 * 25 = 7 + 2×3^2
 * 27 = 19 + 2×2^2
 * 33 = 31 + 2×1^2
 *
 * It turns out that the conjecture was false.
 * What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
 */
fun problem46() {
    val oddCompositeNumbers = (3..Int.MAX_VALUE step 2).asSequence().filterNot(Int::isPrime)
    val primes = listOf(2) + (3..Int.MAX_VALUE step 2).asSequence().filter(Int::isPrime).take(10000)

    val num = oddCompositeNumbers.first {
        for (prime in primes) {
            if (prime > it) return@first true
            var i = 1
            while (true) {
                val sum = prime + 2 * i.square()
                if (sum == it) return@first false
                else if (sum > it) break
                i++
            }
        }
        throw IllegalStateException("Should not reach error")
    }
    println(num)
}

/**
 * The first two consecutive numbers to have two distinct prime factors are:
 *     14 = 2 × 7
 *     15 = 3 × 5
 *
 * The first three consecutive numbers to have three distinct prime factors are:
 *     644 = 2 * 2 × 7 × 23
 *     645 = 3 × 5 × 43
 *     646 = 2 × 17 × 19.
 *
 * Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?
 */
fun problem47() {
    4.primeFactors()
    val num = (3..Int.MAX_VALUE).first {
        it.primeFactors().toSet().size >= 4 &&
                (it + 1).primeFactors().toSet().size >= 4 &&
                (it + 2).primeFactors().toSet().size >= 4 &&
                (it + 3).primeFactors().toSet().size >= 4
    }

    println(num)
}

/**
 * The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
 * Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
 */
fun problem48() {
    val digits = (1..1000).asSequence().map { BigInteger("$it").pow(it) }.fold(BigInteger.ZERO, BigInteger::plus) % BigInteger.TEN.pow(10)
    println(digits)
}